React Notes

1- PROJE OLUSTURMA VE AYAGA KALDIRMA
- En guncel sekliyle bir react projesi su an 'vite' ile acilmaktadir.
    Bunun icin proje yolundayken 'npm create vite@latest -y' ile olusturuyoruz.
    Daha sonra proje ismini yaziyoruz, framework sorusunda olarak React'i (kutuphane) ve dil olarak ise su an icin 'javascript' i seciyoruz.
    Daha sonra cd ile proje adina girip, npm install ve npm run dev komutlarini calistiriyoruz.

2- Syntax 
- Component icerisinde javascript kodlari return keyword'unden once yazilir, return () icerisine yalnizca html kodlari ve oncesinde tanimlanan js 
    degiskenleri jsx seklinde {} yani icerisinde yazilir.
- Component'ler function ile tanimlaniyor.
- Olusturulan companent en asagida export default companentAdi seklinde export edilmesi gerek.
- 'ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)' ornek id si root olan elementi burada render ile App companent'i calistirilmis.

3- Ozellik
- Donerken value,key de ilgili elemente 'key={}' ile deger ver.
- Style vermek icin style={{ color:white, border:none, }}, seklinde verilir ilk suslu jsx in, 2. suslu ise style vermek icin style lar virgul ile coglatilabilinir. 
- Component'lerde return ile geriye donerken ust kapsayici veya Fragment '<></>' olmak zorunda.
- export default companentAdi ile companent'i oldugu gibi export edebilirz, sadece export ile belirli bir kismini export edebilirz. SAdexe export ile doneceksek eger fonksiyonun disinda yapilmasi gereklidir.
- sadece export ile disari cikarilan lar importta {exportEdilenDegisken} seklinde cagrilir.
  import 'IstenilenAD' from './Login' -> export default ile
  import { exportEdilenAd } from './Login' -> sadece export ile
- JS ile JSX arasindaki fark : jsx-> js ve html kullanmak icin kullanilir. JSX'te return (
        <div>Hello</div>
    ) dondugumuzu, js te return (
  React.createElement("div", null, "Hello World") seklinde yazmamiz gerek. Kisaca jsx companent'te return ile direkt html yazmamizi saglar
)

4- Props(property) : Componentler arasi veri tasima islemidir. Componentin cagirildigi yerde custom property name verilip componentin olujstugu yerde 3 fartkli yol ile alinabilinir.
    -- <Product productName="Ayakkabi" price={3200} /> seklinde prop lar tanimlanir
    -1- function Product(props) {
    console.log(props); // {"productName": "Ayakkabi","price": 3200}
    ...
    } : burada fonks adindan sonra parametre ile bir degisken atayip o degisken uzerinden . ile altindaki property lere erisilebilinir. (<div>Isim: {prop.productName}</div>)

    -2- Destructing ile alinabilinir.
    const { productName, price } = props;
    <div>Isim: {productName}</div>

    -3- En sik kullanilan destructing i direkt fonksiyonun parametresinde tanimlama
    NOT : Destructing de {} icerisindeki parametre ile objedeki ayni olmak zorunda.

- main.jsx teki React.StrictMode kaldirinca coklu loglamayi kaldirabiliriz

5- Component icerisinde companent tanimlama
- <Container> <Product /> </Container> // Container companenti parametresinde props olarak children geliyor. Destructing ile Container({ children }) seklinde karsiliyoruz ve yazdirmak istedigimiz yerde {children} ile basiyoruz.

6- useState:hooks
- php deki public string $name; dedigimiz degiskenlerdir React karsiligi useState hooks tur. Ilk basta "import { useState } from 'react'" seklinde import edilmesi gereklidir.
- Tanimlama sekli : const [degiskenAdi, fonkAdi] = useState('string' || [arr] || {obj} || boolean || '');
- Calistirilma sekli : hemen cback func "onClick={() => { setFirstName("Ali") }}" veya oncesinde bi fonk yazip calistirma "onClick={changeName}"
- State in durumu degiskenden sonraki fonksiyonda degistiginde o component tekrar render edilir. const [count, setCount] = useState(0); -> setCount kullanildiginda.
- State in degeri degistiginde tekrardan calistirilmasi uygulamayi yavaslatir.

7- useEffect : hooks
- Sayfa yuklendiginde veya bir state in degeri degistiginde calisir.
- "import { useEffect, useState } from 'react'" seklinde import edilmesi gerekir.
- useEffect(callback, calismaSekli(array[]))
-  useEffect(() => {
    console.log("Ilk kez render edildiginde calisir");
  }, []); // burada ", []" verilmezse her zaman calisir, sadece ", []" verilirse sayfa yuklendiignde 1 defaya mahsus calisir, ", [firstName, lastName]" gibi yukarda tanimlanan state varsa eger o state teki degisiklik gerceklestiginde sadece calisir.

8- className : daha oncesinde style'i "style={{ backgroundColor:white, borderRadius:5px, }}" seklinde vermistik, class'lari ise 'clasname="classadi"' seklinde verebiliriz.

9- attributelere verilen deger sayi veya degisken ise attAdi acildiktan sonra suslu icerisine tirnaksiz yazilmasi gerek.

10- json server ile db'den cekilen fake data olusturma : json serve kurulum

11- fetch veya axios isteklerinde then li bolumler kullanilmayacksa eger async await kullanilmalidir.

12- axios get (listeleme) istegi
async & await li kullanim:
  const getUserById = async (userID) => {
    const response = await axios.get(`${BASE_URL}/users/${userID}`);
    console.log(response.data);
  };

then ve catch li kullanim
  const getUserById = (userID) => {
    axios.get(`${BASE_URL}/users/${userID}`)
      .then((response) => {
        console.log(response.data);
      }).catch((error) => {
        console.log("Hata: ", error);
      });
  };

13- axios post (ekleme) istegi icin fonk olusturup useEffect ile cagirdim ve icerisine newUser'i atadim.
  // fonk atama
  const createUser = async (newUser) => {
    const donenCevap = await axios.post(`${BASE_URL}/users`, newUser);
    console.log('donenCevap : ', donenCevap.data);
  };

  //fonk cagirma
   useEffect(() => {
    const newUser = {
      "username": "Axios Post Istegi",
      "password": "axios"
    };
    createUser(newUser);
  }, []);

14- axios put (guncelleme) istegi icin fonk olusturup guncellenecek ID yi ve yeni degerleri parametresinde tanimladim. Daha sonra cagirdim.
  // fonks atama
  const updateUser = async (userId, updatedUser) => {
    const response = await axios.put(`${BASE_URL}/users/${userId}`, updatedUser);
    console.log(response.data);
  };

  //fonk cagirma 2 numara id'li kullanici yi yeni bilgilerle degiskene atamadan set ettim.
   useEffect(() => {
    updateUser(2, {
      "username": "serkan",
      "password": "aras"
    });
  }, []);

15- axios delete (silme) istegi icin fonk olusturup fonk parametresinde silinencek userin id sini tanimladim.
  // fonks atama
  const deleteUserById = async (userId) => {
    const response = await axios.delete(`${BASE_URL}/users/${userId}`);
    console.log(response.data);
  };

  //fonk cagirma 2 numara id'li kullanici yi yeni bilgilerle degiskene atamadan set ettim.
   useEffect(() => {
    deleteUserById(2);
  }, []);

16- Redux Toolkit : 
  - kutuphane'lerini import ediyoruz.
  - store(slice'lari depolayan yer) tanimliyoruz : configureStore fonksiyonundaki reducer'a key,val seklinde olusturulan slice'i atiyoruz
  - main.jsx te provider ile sarip propsa store u veriyoruz.
  - ortak tutulan degisken ve funcs lar slice larda tutulur.
  - slice'lari store ile baglamak icinde yukarda da anlatildigi gibi reducer'a key, value seklinde atanilmasi gerek
  - daha sonra App.jsx te useSelector ile state'lere, useDispatch ile fonksiyonlara erisilinir.
  

17- React Router-Dom
  - npm i react-router-dom ile indiriyoruz
  - main.jsx teki app BrowserRoute ile saririyoruz.
    import { BrowserRouter } from 'react-router-dom';

    ReactDOM.createRoot(document.getElementById('root')).render(
      <BrowserRouter>
        <App />
      </BrowserRouter>,
    ) 

  - routing yapilan yerde kutuphaneleri import ediyoruz.
    "import { Routes, Route } from 'react-router-dom';"

    -Routes icerisine Route tanimliyoruz ve 2 adet props aliyor path ve element
    function App() {

      return (
        <>
          <Routes>
            {/* 2 tane props alir path ve element */}
            <Route path='/' element={<Home />} />
          </Routes>
        </>
      )
    }

  - Route yonlendirmesi icin Link kullaniyoruz ve to="path"
  import React from 'react'
  import { Link } from 'react-router-dom'

  function Header() {
      return (
          <div>
              <Link to="/">Anasayfa</Link>
              <Link to="/about">Hakkimizda</Link>
              <Link to="/product">Urunler</Link>
              <Link to="/contact">Iletisim</Link>
          </div>
      )
  }

  export default Header




  - Ic ice linkler /about/employee || /about/company
  - Child sayfasini almak icin Parent ta "<Outlet />" componenti tanimlanmasi gerek
    return (
      <div>
          <h1>About</h1>
          <Link className='link' to="employee">Calisanlar Hk</Link>
          <Link className='link' to="company">Sirketler Hk</Link>

          <Outlet />
      </div>
    )

  - Child routelarin path i ve to suna "/" eklenmez
    <Route path='/about' element={<About />}>
        <Route path='employee' element={<EmployeeAbout />} />
        <Route path='company' element={<CompanyAbout />} />
    </Route>

  

  - useNavigate() : bir seye tiklanildiginda onu herhangi bir path e yonlendirdigimiz hook tur.
    import { useNavigate } from 'react-router-dom';

    const navigate = useNavigate();
    <button onClick={() => navigate(`/product-details/${id}`)}>DETAYI GOR</button>
    <Route path='/product-details/:id' element={<ProductDetails />} />
    /product-details/:id -> buradaki :id dinamik yer tutucu degisken. ProductDetails componentine gitti. Asagida companentte useParams ile degeri aldik

  - useParams() : parametre ile gelenleri karsilar.
      const params = useParams();
      console.log(params);

18- Custom Hooks : use ile baslatilmasi gerekir. Bir kere yaz her yerden kullan
  Or: hooks/useCounter.jsx isimli component daha sonra rfce ile componenti olustur. Buraya fonksiyonlar, degiskenleri vs obje seklinde geri dondur.
      Kullanilan yerde object destructing ile yakala:
    `
      import { useState } from 'react'

      function useCounter() {
          const [count, setCount] = useState(0);

          const increase = () => {
              setCount(count + 1);
          };

          const decrease = () => {
              count > 0 ? setCount(count - 1) : null;
          };

          return { count, increase, decrease }
      }

      export default useCounter
    `
    `
      import useCounter from '../hooks/useCounter'
      import './App.css'

      function App() {
        const { count, increase, decrease } = useCounter();

        return (
          <>
            <div>{count}</div>
            <button onClick={decrease}>Azalt</button>
            <button onClick={increase}>Arttir</button>
          </>
        )
      }

      export default App
    `

19- Formik Yup validation icin kullanilir.
  2 paket kurulumu gerceklestirilir ve formik ile inputlar birbirne baglanilir.
  Schemas klasoru olusturup hata mesajlarini kurallari orada tanimliyoruz. 
  Ornek: RegisterForm componenti icin: Burada useFormik hooksu ile obj destructing ile almak istedigimiz verileri cekiyoruz. form input valuelarina initialValues taki degerleri atiyoruz.
  Hata olmasi durumunda ise errors ile basiyoruz. Errors lar schemas tan gelmektedir. Ornek schemas asagida mevcut 
      import { useFormik } from 'formik';
      import { registerFormSchemas } from '../src/schemas/RegisterFormSchemas';

      function RegisterForm() {

          const submit = (values, actions) => {
              setTimeout(() => actions.resetForm(), 2000);
          };

          const { values, errors, handleChange, handleSubmit } = useFormik({
              initialValues: {
                  email: '',
                  age: '',
                  password: '',
                  confirmPassword: '',
                  term: '',
              },
              validationSchema: registerFormSchemas,
              onSubmit: submit
          });


          return (
              <div>
                  <form onSubmit={handleSubmit}>
                      <div className='input-div'>
                          <label>Email</label>
                          <input type='text' id='email' placeholder='Email Giriniz' value={values.email} onChange={handleChange} />
                          {errors.email && <p className='input-error'>{errors.email}</p>}
                      </div>
                      <div className='input-div'>
                          <label>Yas</label>
                          <input type='number' min={1} id='age' placeholder='Yas Giriniz' value={values.age} onChange={handleChange} />
                          {errors.age && <p className='input-error'>{errors.age}</p>}
                      </div>
                  </form>
              </div>
          )
      }

      export default RegisterForm

      Schemas :
      import * as yup from 'yup';

      export const registerFormSchemas = yup.object().shape({
          email: yup.string().email("Gecerli email adresi giriniz.").required("Email alani zorunludur"),
          age: yup.number().positive("Pozitif bir deger giriniz.").integer("Tam Sayi giriniz").required("Yas alani zorunludur"),
          password: yup.string().required("Sifre alani zorunludur"),
          confirmPassword: yup.string().required("Sifre tekrari zorunludur").oneOf([yup.ref('password', yup.password)], 'Sifre tekrari ayni olmalidir.'),
          term: yup.boolean().required("Sozlesme alani zorunludur"),
      });